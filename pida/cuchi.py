# Todo
# [ ] Calls in the middle of functions are red edges
# [x] Jumps in a middle of an instruction branch the analysis path.
#     Paths may join in the future or not, some path may end abruptly (bad instructions)
# [ ] Basic blocks generated by branching the analysis by unaligned jump are colored diff.
#     [ ] Pairs of overlapping basic blocks (may be more than 2) have a special color
#     [ ] Pairs of overlapping basic blocks are connected by an special edge
# [ ] Functions with more than 1 entry point may be
#     [ ] Separate functions with overlapping basic blocks
#     [ ] Same function with more than a single entry poiny (entry points with special color)
# [x] Proper basic block spliting. 
#     [x] Letting the two new blocks know each other
#     [x] Only spliting in start of instruction

# [ ] In function's analysis when a basic block from the queue already exists,
#     it's discarded, however, its referers must be pointed to the existing basic block

# [ ] In module's analysis when a function from the queue already exists,
#     it's discarded, however, its callers must be pointed to the existing function

# [x] Bug when spliting basic blocks with edges. For example, in winmine's sub_1001915

# Disassembling
# [ ] Indirect calls and jumps through absolute addresses
# [ ] Register tracking for indirect calls and jumps?
# [ ] Jump tables?
# [ ] Track SEH for defining new functions (Handler and Filter)
# [ ] Add some interactivity
#     [ ] Mark as code (or function) and start disassembling (new entry point)

# Information
# [ ] Use exports as entry points
# [ ] Put proper names on Imports
# [ ] Use debuging information and pdb files

# Invariants:
#   you should try to avoid putting analyzed things on the queue, however,
#      if they are already analyzed when they are poped from the queue, they wont be
#      analyzed again. Specially, you should not put non-empty things on the queue

import pgraph

import pefile
from pydbg import pydasm

debug = 0

def log(s):
    if debug:
        print s

class module(pgraph.graph):
    def load(self, fileName):
        pe = pefile.PE(fileName)
        self.base = pe.OPTIONAL_HEADER.ImageBase
        self.ea_start = pe.OPTIONAL_HEADER.AddressOfEntryPoint+self.base

        self._exports = []
        self.image = pe.get_memory_mapped_image()

    def exports(self):
        return self._exports
    
    def analyze(self, maxDepth = -1):
        # try:
            if not maxDepth: return

            fqueue = []

            fqueue.extend(self.exports())
            fqueue.append(self.function_with_entry(self.ea_start))

            while fqueue:
                func = fqueue.pop(0)  # fifo

                other_func = self.function_with_entry(func.ea_start)
                if len(other_func.nodes):
                    # the function is already known, and has already been analyzed
                    log( "Skipping already known function at 0x%08x" % func.ea_start)
                    continue

                called_addrs = func.analyze_image(self.image, self.base, maxDepth - 1)
                if called_addrs:
                    for addr in called_addrs:
                        called = self.function_with_entry(addr)

                        if called.is_empty():
                            # done add if called alrady exists,
                            # XXX: must add a call graph edge
                            fqueue.append(called)
        # except Exception, e:
        #     print e

    def function_with_entry(self, address):
        func = self.find_node('id', address)
        if func: return func

        func = function(address)
        self.add_node(func)
        return func
    
def is_branch(ins):
    return ins.type in [
        pydasm.INSTRUCTION_TYPE_CALL,
        pydasm.INSTRUCTION_TYPE_JMP,
        pydasm.INSTRUCTION_TYPE_JMPC,
        pydasm.INSTRUCTION_TYPE_RET]

class function(pgraph.graph, pgraph.node):
    def __init__(self, entryPoint):
        pgraph.graph.__init__(self, entryPoint)
        pgraph.node.__init__(self, entryPoint)
        
        self.ea_start = entryPoint
        self.minAddr = entryPoint
        self.maxAddr = entryPoint

        self.is_import = 0
        self.name = self.get_name()

    def is_empty(self):
        return self.minAddr == self.maxAddr

    def analyze_image(self, image, base, maxDepth = -1):
        # return a list of the addresses called from this function
        if not maxDepth: return

        log( "Analyzing function at 0x%x (nodes: %d)" % (self.ea_start, len(self.nodes)))

        bbqueue = []
        called  = []

        bbqueue.append(self.basic_block_with_entry(self.ea_start))

        while bbqueue:
            block = bbqueue.pop(0)  # fifo
            log( "  pop: %s" % block)

            other_block = self.basic_block_with_entry(block.ea_start)
            if (block != other_block):
                log( "  dup block: %s" % block)
                if not other_block.is_empty():
                    # skip it if another basic block already exists with same ea_start
                    continue
                else:
                    # XXX: other block is empty, we must replace it
                    pass

            called_addrs, jumped_addrs = block.analyze_image(image, base, maxDepth - 1, function = self)

            self.maxAddr = max(self.maxAddr, block.endAddr)

            self.add_node(block)
            if jumped_addrs:
                for addr in jumped_addrs:
                    # may be more than one for jmp tables
                    # XXX: next line is trick
                    if addr >= self.minAddr:
                        jumped = self.basic_block_with_entry(addr)

                        if jumped.is_empty():
                            # dont add if there's already a block with same ea_start,
                            # XXX: must add a block to block edge
                            bbqueue.append(jumped)
            called += called_addrs

        for block in self.nodes.values():
            for src,dst in block.edges:
                log('   adding edge %08x -> %08x with src %08x (%d)' % (block.ea_start, dst, src, len(self.edges)))
                edge = pgraph.edge.edge(block.ea_start, dst)
                self.add_edge(edge)

        return called

    def basic_block_with_entry(self, addr):
        self.minAddr = min(addr, self.minAddr)

        block = self.find_node('id', addr)
        if block: return block

        for block in self.nodes.values():
            # print ". finding 0x%x in block %s" % (addr, block)
            if block.contains(addr):
                # ablock already contained the address. Break it
                if block.ea_start == addr:
                    return block
                else:
                    new_block = block.split_at(addr)
                    self.add_node(new_block)
                    return new_block

        answer = basic_block(addr)
        return answer

    def has_basic_block_with_entry(self, addr):
        return self.nodes.has_key(addr)

    def __str__(self):
        return "function(0x%x-0x%x-0x%x)" % (self.minAddr, self.ea_start, self.maxAddr)

    def get_name(self):
        return "sub_%x" % self.ea_start

    def render_node_udraw (self, graph):
        '''
        Overload the default node.render_node_udraw() routine to create a custom label. Pass control to the default
        node renderer and then return the merged content.

        @type  graph: pgraph.graph
        @param graph: Top level graph object containing the current node

        @rtype:  String
        @return: Contents of rendered node.
        '''

        if self.is_import:
            self.label = "%s" % (self.name)
        else:
            self.label  = "%08x %s\\n" % (self.ea_start, self.get_name())
            self.label += "size: %d"   % (self.maxAddr - self.minAddr)

        return super(function, self).render_node_udraw(graph)

class basic_block(pgraph.node):
    def __init__(self, entryPoint):
        pgraph.node.__init__(self, entryPoint)

        self.ea_start = entryPoint
        self.endAddr = entryPoint
        self.instructions = {}
        self.edges = []

    def is_empty(self):
        return self.ea_start == self.endAddr

    def analyze_image(self, image, base, maxDepth = -1, function = None):
        if not maxDepth: return

        log( "  Analyzing basic block at 0x%x" % self.ea_start)
        called = []
        jumped = []    # more than 1 for jump tables
        off = self.ea_start-base
        ins = None
        while 1:
            if function.has_basic_block_with_entry(off+base):
                if ins:
                    jumped.append(base+off)
                    # in the next line ins is the previous instruction
                    # which can't be empty by logic:
                    # a block can't run in another block on the first instruction
                    self.edges.append((base+off-ins.length, base+off))
                    log( "fall-through edge: 0x%08x-0x%08x" % (base+off-ins.length, base+off))
                    break
                else:
                    log( "first instruction fall-through: 0x%08x" % (base+off))

            ins = pydasm.get_instruction(image[off:off+16], pydasm.MODE_32)
            if ins:
                self.instructions[off+base] = instruction(ins, off+base)

                off += ins.length
                if   ins.type == pydasm.INSTRUCTION_TYPE_CALL:
                    if ins.op1.type == pydasm.OPERAND_TYPE_IMMEDIATE:
                        called.append(base+off+ins.op1.immediate)
                elif ins.type == pydasm.INSTRUCTION_TYPE_JMPC:
                    jumped.append(base+off)
                    jumped.append(base+off+ins.op1.immediate)
                    self.edges.append((base+off-ins.length, base+off))
                    self.edges.append((base+off-ins.length, base+off+ins.op1.immediate))
                    break
                elif ins.type == pydasm.INSTRUCTION_TYPE_JMP:
                    if (ins.op1.flags & 0x00ff0000 == 0x00070000):
                        # operand is immediate relative to eip
                        jumped.append(base+off+ins.op1.immediate)
                        self.edges.append((base+off-ins.length, base+off+ins.op1.immediate))
                    break
                elif ins.type == pydasm.INSTRUCTION_TYPE_RET:
                    break
            else:
                break

        self.endAddr = base+off
        """
        print "  basic block result: %s called:" % self,
        for i in called: print "0x%x, " % i,
        print "jumped:",
        for i in jumped: print "0x%x, " % i,
        print
        """
        return called, jumped

    def contains(self, addr):
        # return self.ea_start <= addr < self.endAddr
        # the next line is true if there is a real instruction contained,
        # not if jump-into-middle-of-instruction
        return self.instructions.has_key(addr)

    def split_at(self, addr):
        if not self.contains(addr):
            raise Exception, "Can't split block %s at 0x%08x" % (self, addr)

        log( "  spliting block %s at 0x%08x" % (self, addr))

        self.instructions[addr]  # will raise if spliting at middle of ins, good for now

        answer = basic_block(addr)
        answer.endAddr = self.endAddr
        self.endAddr = addr
        
        lastIn = self.ea_start

        for ins in self.instructions:
            if ins >= addr:
                answer.instructions[ins] = self.instructions[ins]
            else: lastIn = max(lastIn, ins)

        for ins in answer.instructions:
            del self.instructions[ins]

        for edge in self.edges:
            if edge[0] >= addr:
                answer.edges.append(edge)

        for edge in answer.edges:
            self.edges.remove(edge)

        self.edges.append((lastIn, answer.ea_start))
        
        return answer

    def __str__(self):
        return "basic_block: 0x%x-0x%x" % (self.ea_start, self.endAddr)

    def render_node_udraw (self, graph):
        '''
        Overload the default node.render_node_udraw() routine to create a custom label. Pass control to the default
        node renderer and then return the merged content.

        @type  graph: pgraph.graph
        @param graph: Top level graph object containing the current node

        @rtype:  String
        @return: Contents of rendered node.
        '''

        self.label = ""

        for instruction in self.sorted_instructions():
            self.label += "%08x  %s\\n" % (instruction.ea_start, instruction.get_text())

        return super(basic_block, self).render_node_udraw(graph)

    def sorted_instructions (self):
        '''
        Return a list of the instructions within the graph, sorted by id.

        @rtype:  List
        @return: List of instructions, sorted by id.
        '''

        instruction_keys = self.instructions.keys()
        instruction_keys.sort()

        return [self.instructions[key] for key in instruction_keys]

class instruction:
    def __init__(self, pydasm_instruction, entryPoint):
        self.ea_start  = entryPoint
        self.ins = pydasm_instruction
        self.disasm = self.get_text()
        log("%08x: (%2d) %s" % (self.ea_start, self.ins.length, self.disasm))

    def get_text(self):
        return pydasm.get_instruction_string(
                self.ins, pydasm.FORMAT_INTEL, self.ea_start)

if __name__ == "__main__":
    import sys

    debug = 1    
    pa = module()
    pa.load(sys.argv[1])
    pa.analyze()
    for f in pa.nodes:
        print "Function at: 0x%x" % f
        print pa.nodes[f].render_graph_udraw()
        for b in pa.nodes[f].nodes:
            print "  %s" % pa.nodes[f].nodes[b]
            # print pa.nodes[f].nodes[b].render_node_udraw(pa)

# bug: pydasm.get_instruction_stirng(ins, pydasm.FORMAT_INTEL, off*base) weird crash!
