//
// AUTO-GENERATED BY PAIMEI
// http://www.openrce.org
//

#include <idc.idc>

// convenience wrapper around assign_color_to() that will automatically resolve the 'start' and 'end' arguments with
// the start and end address of the block containing ea.
static assign_block_color_to (ea, color)
{
    auto block_start, block_end;

    block_start = find_block_start(ea);
    block_end   = find_block_end(ea);

    if (block_start == BADADDR || block_end == BADADDR)
        return BADADDR;

    assign_color_to(block_start, block_end, color);
}

// the core color assignment routine.
static assign_color_to (start, end, color)
{
    auto ea;

    if (start != end)
    {
        for (ea = start; ea < end; ea = NextNotTail(ea))
            SetColor(ea, CIC_ITEM, color);
    }
    else
    {
        SetColor(start, CIC_ITEM, color);
    }
}

// returns address of start of block if found, BADADDR on error.
static find_block_start (current_ea)
{
    auto ea, prev_ea;
    auto xref_type;

    // walk up from current ea.
    for (ea = current_ea; ea != BADADDR; ea = PrevNotTail(ea))
    {
        prev_ea = PrevNotTail(ea);

        // if prev_ea is the start of the function, we've found the start of the block.
        if (GetFunctionAttr(ea, FUNCATTR_START) == prev_ea)
            return prev_ea;

        // if there is a code reference *from* prev_ea or *to* ea.
        if (Rfirst0(prev_ea) != BADADDR || RfirstB0(ea) != BADADDR)
        {
            xref_type = XrefType();

            // block start found if the code reference was a JMP near or JMP far.
            if (xref_type == fl_JN || xref_type == fl_JF)
                return ea;
        }
    }

    return BADADDR;
}

// returns address of end of block if found, BADADDR on error.
static find_block_end (current_ea)
{
    auto ea, next_ea;
    auto xref_type;

    // walk down from current ea.
    for (ea = current_ea; ea != BADADDR; ea = NextNotTail(ea))
    {
        next_ea = NextNotTail(ea);

        // if next_ea is the start of the function, we've found the end of the block.
        if (GetFunctionAttr(ea, FUNCATTR_END) == next_ea)
            return next_ea;

        // if there is a code reference *from* ea or *to* next_ea.
        if (Rfirst0(ea) != BADADDR || RfirstB0(next_ea) != BADADDR)
        {
            xref_type = XrefType();

            // block end found if the code reference was a JMP near or JMP far.
            if (xref_type == fl_JN || xref_type == fl_JF)
                return next_ea;
        }
    }

    return BADADDR;
}

// return the lower case version of 'str'.
static tolower (str)
{
    auto i, c, new;

    new = "";

    for (i = 0; i < strlen(str); i++)
    {
        c = substr(str, i, i + 1);

        if (ord(c) >= 0x41 && ord(c) <= 0x5a)
            c = form("%s", ord(c) + 32);

        new = new + c;
    }

    return new;
}

// return the blended color between 'old' and 'new'.
static blend_color (old, new)
{
    auto r, g, b, bold, gold, rold, bnew, gnew, rnew;

    bold = (old & 0xFF0000) >> 16;
    gold = (old & 0x00FF00) >> 8;
    rold = (old & 0x0000FF);

    bnew = (new & 0xFF0000) >> 16;
    gnew = (new & 0x00FF00) >> 8;
    rnew = (new & 0x0000FF);

    b    = (bold + (bnew - bold) / 2) & 0xFF;
    g    = (gold + (gnew - gold) / 2) & 0xFF;
    r    = (rold + (rnew - rold) / 2) & 0xFF;

    return (b << 16) + (g << 8) + r;
}

// return the next empty Mark slot
static get_marked_next()
{
    auto slot;
    slot = 1;

    // loop until we find an empty slot
    while(GetMarkedPos(slot) != -1)
        slot++;

    return slot;
}

// executed on script load.
// This dumps out the idc file
static main()
{
    auto base, color, this_module, next_mark;

    base        = MinEA() ;    // cheap hack
    this_module = GetInputFile();
    next_mark = get_marked_next();

    if (tolower(this_module) == "calculate")
    {

        color = 0x3c0000;
        if (GetColor(base + 0x00002cbc, CIC_ITEM) == DEFCOLOR)
            assign_block_color_to(base + 0x00002cbc, color);


        color = 0x3c0000;
        if (GetColor(base + 0x00002d29, CIC_ITEM) == DEFCOLOR)
            assign_block_color_to(base + 0x00002d29, color);


        color = 0x3c0000;
        if (GetColor(base + 0x00002d48, CIC_ITEM) == DEFCOLOR)
            assign_block_color_to(base + 0x00002d48, color);


        color = 0x3c0000;
        if (GetColor(base + 0x00002d1d, CIC_ITEM) == DEFCOLOR)
            assign_block_color_to(base + 0x00002d1d, color);

    }
}
